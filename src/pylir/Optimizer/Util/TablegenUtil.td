// Licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef PYLIR_TABLEGEN_UTIL
#define PYLIR_TABLEGEN_UTIL

include "mlir/IR/AttrTypeBase.td"

class ParamSpec<AttrOrTypeParameter m_type, string m_name, string m_defaultArg = ""> {
	AttrOrTypeParameter type = m_type;
	string name = m_name;
	string defaultArg = m_defaultArg;
}

class ParamSpecBuilder<list<ParamSpec> spec, code extraCode = ""> : AttrBuilder<!dag(ins,
    !foreach(x, spec, CArg<x.type.cppType, !if(!not(!empty(x.type.defaultValue)), "{}", x.defaultArg)>),
        !foreach(x, spec, x.name)),
	!interleave(!foreach(x, !filter(x, spec, !not(!empty(x.type.defaultValue))),
					x.name # " = " # x.name # " ? " # x.name # " : " # x.type.defaultValue # ";\n"), "") # extraCode #
	"return Base::get($_ctxt, " # !interleave(!foreach(x, spec, x.name), ", ") # ");"
>;

class DefaultType<string name, string description = ""> : DefaultValuedParameter<"::pylir::Py::RefAttr",
	"::pylir::Py::RefAttr::get($_ctxt, ::pylir::Builtins::" # name # ".name)", description>;

class CustomPrint<AttrOrTypeParameter x, string elementParse = ?, string elementPrint = ?>
	: AttrOrTypeParameter<x.cppType, x.summary, x.cppAccessorType>
{
	let allocator = x.allocator;
	let comparator = x.comparator;
	let cppStorageType = x.cppStorageType;
	let syntax = x.syntax;
	let defaultValue = x.defaultValue;

	let parser = elementParse;
	let printer = elementPrint;
}

class ListPrint<string type, string delim, string elementParse = "", string elementPrint = ""> : ArrayRefParameter<type>
{
	let parser = [{
		[&]() -> mlir::FailureOr<llvm::SmallVector<}] # type # [{>> {
			llvm::SmallVector<}] # type # [{> array;
			if ($_parser.parseCommaSeparatedList(::mlir::AsmParser::Delimiter::}] # delim # [{, [&]() -> mlir::ParseResult {
					auto temp = }] # !if(!empty(elementParse), "::mlir::FieldParser<" # type # ">::parse($_parser)", elementParse) # [{;
					if (mlir::succeeded(temp))
					{
						array.push_back(std::move(*temp));
					}
					return static_cast<mlir::LogicalResult>(temp);
				}))
			{
				return ::mlir::failure();
			}
			return array;
		}()
	}];

	let printer = [{
		$_printer << '}] # !cond(!eq(delim, "Paren") : "(", !eq(delim, "Square") : "[", !eq(delim, "Braces") : "{") # [{';
		llvm::interleaveComma($_self, $_printer, [&](auto&& x){ }] # !if(!empty(elementPrint), "$_printer << x;", !subst("$_self", "x", elementPrint)) # [{; });
		$_printer << '}] # !cond(!eq(delim, "Paren") : ")", !eq(delim, "Square") : "]", !eq(delim, "Braces") : "}") # [{';
	}];
}

/// Base class for traits serving as implementations of interfaces.
class InterfaceImplementation<InterfaceTrait interface, code extraClassDeclaration, code extraClassDefinition>
    : NativeTrait<"", ""> {
    let trait = interface.trait;
    let cppNamespace = interface.cppNamespace;
    let extraConcreteClassDeclaration = extraClassDeclaration;
    let extraConcreteClassDefinition = extraClassDefinition;
}

/// Trait used to automatically `interface` through the code generated by `extraClassDeclaration` and
/// `extraClassDefinition`.
/// Both of these inject code into any Op class they are attached to. The code in `extraClassDeclaration` is put inside
/// the class in the header file, while `extraClassDefinition` is generated in the source file.
/// `extraClassDefinition` may contain `$cppClass` which is later replaced by the class name of the Op this trait is
/// attached to. This allows injecting interface implementations into the class.
class OpInterfaceImplementation<OpInterfaceTrait interface, code extraClassDeclaration, code extraClassDefinition>
    : InterfaceImplementation<interface, extraClassDeclaration, extraClassDefinition> {
  list<Trait> dependentTraits = [];
}


#endif
